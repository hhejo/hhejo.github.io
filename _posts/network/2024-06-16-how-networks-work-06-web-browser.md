---
title: 1%의 네트워크 원리 (06) - 웹 브라우저가 메시지를 생성
date: 2024-06-16 08:11:23 +0900
last_modified_at: 2024-06-18 13:27:09 +0900
categories: [Network]
tags: [network]
---

웹 브라우저의 내부 탐험

# 1%의 네트워크 원리 (06) - 웹 브라우저가 메시지를 생성

1. HTTP 리퀘스트 메시지 작성
   - 사용자가 브라우저에 URL 입력
   - 브라우저가 URL 해석
   - 리퀘스트 메시지 생성(HTTP 프로토콜)
2. 웹 서버의 IP 주소를 DNS 서버에 조회
   - OS에 의뢰해 웹 서버에 송신
   - 상대의 IP 주소 필요
   - URL 안의 웹 서버의 도메인명을 DNS 서버에 조회 - IP 주소 조사
3. 전 세계의 DNS 서버가 연대
   - DNS 서버가 IP 주소를 조사
   - 전 세계의 수만 대의 DNS 서버들이 연대
4. 프로토콜 스택에 메시지 송신을 의뢰
   - 메시지를 웹 서버에 송신하도록 OS에 의뢰

## 01 HTTP 리퀘스트 메시지 작성

### 1 탐험 여행은 URL 입력부터 시작

URL(Uniform Resource Locator)

- `http:`, `file:`, `mailto:`, `ftp:`, ...

Protocol

- 통신 동작의 규칙을 정한 것
- HTTP(HyperText Transfer Protocol)
- FTP(File Transfer Protocol)

도메인명

- `www.cyber.co.kr`
- 마침표로 구분하여 표현하는 이름

### 2 브라우저는 먼저 URL을 해독

URL의 요소

```
http: // 웹서버명 / 디렉토리명 / ... / 파일명

http://www.lab.cyber.co.kr/dir1/file1.html
```

- `http:`: 프로토콜 - 데이터 출처에 엑세스하는 방법
- `//`: 나중에 이어지는 문자열이 서버의 이름임을 나타냄
- `웹서버명`
- (이 아래는 생략 가능)
- `/`
- `디렉토리명`
- `/`
- `파일명`

### 3 파일명을 생략한 경우

대부분의 서버가 `index.html` 또는 `default.htm`이라는 파일명 설정

```
http://www.lab.cyber.co.kr/dir/
http://www.lab.cyber.co.kr/
http://www.lab.cyber.co.kr
http://www.lab.cyber.co.kr/whatisthis
```

1. 루트 디렉토리(`/`) 아래 `dir/` 디렉토리
2. 루트 디렉토리(`/`)
3. 루트 디렉토리가 생략됨
4. `whatisthis`라는 파일 혹은 디렉토리

### 4 HTTP의 기본 개념

HTTP

- 리퀘스트 메시지
  - 무엇을: URI(Uniform Resource Identifier)
  - 어떻게 해서: Method
    - GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE, CONNECT
    - GET은 많아야 수백 바이트 전송
- 응답 메시지
  - ...스테이터스
- HTTP 버전: `1.0`, `1.1`

### 5 HTTP 리퀘스트 메시지 생성

- 브라우저는 URL을 해독
- 웹 서버, 파일명을 판단
- 이것을 바탕으로 HTTP 리퀘스트 메시지 생성

리퀘스트 메시지

1. 리퀘스트 라인(1줄): `메서드 공백 URI 공백 HTTP버전`
2. 메시지 헤더 + 공백 1줄
3. 메시지 본문

응답 메시지

1. 스테이터스 라인(1줄): `HTTP버전 공백 스테이터스코드 공백 응답문구`
2. 메시지 헤더 + 공백 1줄
3. 메시지 본문(바이너리 데이터)

헤더의 종류

- 제너럴 헤더
- 리퀘스트 헤더
- 응답 헤더
- 엔티티 헤더

### 6 리퀘스트 메시지를 보내면 응답이 되돌아옴

한 개의 리퀘스트에 한 개의 응답

스테이터스 코드

- 1XX: 처리의 경과 상황 등을 통지
- 2XX: 정상 종료
- 3XX: 무언가 다른 조치 필요
- 4XX: 클라이언트측 오류
- 5XX: 서버측 오류

## 02 웹 서버의 IP 주소를 DNS 서버에 조회

### 1 IP 주소의 기본

브라우저

- 메시지를 네트워크에 송출하는 기술이 없음
- HTTP 메시지를 OS에 의뢰해 웹 서버로 전송

라우터와 허브

- 라우터: 패킷을 중계하는 장치의 일종
- 허브: 패킷을 중계하는 장치의 일종 (리피터 허브, 스위칭 허브)

서브넷

- 작은 네트워크
- 허브에 몇 대의 PC가 접속된 것
- 서브넷은 서브넷으로 구성됨

```
- 라우터
  - 라우터
    - 허브
      - 클라이언트
      - 클라이언트
    - 서브넷
    - 서브넷
  - 서브넷
- 서브넷
```

IP 주소

- 32비트의 디지털 데이터
- 8비트 + 8비트 + 8비트 + 8비트 + 넷마스크
- 네트워크 번호(OO동) + 호스트 번호(OO번지)

넷마스크

- 1: 네트워크 번호
- 0: 호스트 번호
- 호스트 번호가 모두 `0`(0): 서브넷 자체
- 호스트 번호가 모두 `1`(255): 서브넷에 있는 기기 전체에 패킷을 보내는 브로드캐스트

```
10.11.12.13/255.255.255.0
10.11.12.13/24
```

- 위와 아래는 동일
- 24는 네트워크 번호의 비트 수를 의미

### 2 도메인명과 IP 주소를 구분해서 사용하는 이유

도메인명과 IP 주소

- TCP/IP의 네트워크는 IP 주소로 통신 상대 지정
- URL에 IP 주소를 써도 올바르게 작동
- 사람은 이름을 사용하고 라우터는 IP 주소를 사용
- IP 주소는 총 32비트를 사용하지만 도메인명은 수십~255바이트를 사용

DNS(Domain Name System)

- 이름과 IP주소를 찾음

### 3 Socket 라이브러리가 IP 주소를 찾는 기능을 제공

DNS 클라이언트

- DNS 리졸버 혹은 리졸버라 불림
- Socket 라이브러리 내 존재
- DNS 서버로 IP 주소를 조회

DNS 서버

- 해당 요청을 응답
- 네임 리졸루션

Socket 라이브러리

- OS에 포함된 네트워크 기능을 애플리케이션에서 호출하기 위한 것들을 모아둠

### 4 리졸버를 이용해 DNS 서버 조회

```
<메모리 영역> = gethostbyname(도메인명);
```

### 5 리졸버 내부의 작동

1. 네트워크 애플리케이션
   - 이 경우 브라우저
2. 리졸버
3. 프로토콜 스택
4. LAN 어댑터
5. DNS 서버
   - DNS 서버의 IP 주소는 TCP/IP 설정 항목으로 컴퓨터에 미리 설정됨

## 03 전세계의 DNS 서버가 연대

### 1 DNS 서버의 기본 동작

DNS 서버

- 클라이언트에서 조회 메시지 받고 응답 메시지 회답

조회 메시지: 이름, 클래스, 타입

- 이름
  - 서버, 메일 배송 목적지 등
- 클래스
  - 항상 인터넷을 나타내는 `IN`
  - 인터넷 외 네트워크에서의 이용까지 고려했었음
  - 지금은 인터넷 외의 네트워크는 소멸
- 타입
  - 이름에 어떤 타입의 정보가 지원되는지 나타냄
  - `A`: 이름에 IP 주소 지원됨(Address)
  - `MX`: 이름에 메일 배송 목적지 지원됨
    - 메일 서버의 우선순위, 메일 서버의 이름, 메일 서버의 IP 주소
  - `PTR`: IP 주소에서 이름 조사
  - `CNAME`: 이름에 alias 붙이기
  - `NS`: DNS 서버의 IP 주소 등록
  - `SOA`: 도메인 자체의 속성 정보를 등록

`www`

- 최초에 웹의 구조를 만들 때 `www`라는 이름으로 웹 서버를 등록한 것들이 많았어서 관례가 됨

```
tone@cyber.co.kr
```

- 이름: `cyber.co.kr`
- 클래스: `IN`
- 타입: `MX`
- 응답 반환 예시: `10 mail.cyber.co.kr`

메일 서버의 우선순위

- 메일 배송 목적지로 복수의 메일 서버가 등록되어 있을 때 어느 메일 서버를 우선 선택해야 하는지를 판단하기 위한 값
- 작은 값으로 등록된 메일 서버를 우선 선택

이러한 정보들은 등록정보가 DNS 서버의 설정파일 등에 입력됨

- 리소스 레코드: 테이블의 1행 정보

### 2 도메인의 계층

조회 메시지를 받은 DNS 서버에 정보가 등록되어 있지 않은 경우

- 정보를 분산시켜 다수의 DNS 서버에 등록
- 다수의 DNS 서버가 연대해 어디에 정보가 등록되어 있는지 찾아내는 구조

계층적 구조

```
www.lab.cyber.co.kr
```

- 오른쪽으로 갈수록 상위계층
- 왼쪽으로 갈수록 하위(sub) 도메인
- 점(`.`)이 계층을 구분
- 도메인을 하나의 부서로 볼 수 있음

### 3 담당 DNS 서버를 찾아 IP 주소를 가져옴

인터넷에는 DNS 서버가 수만 대

```
www.lab.glasscom.com.
```

- 최상위 도메인이 `com`
- 맨 뒤의 점(`.`)이 루트 도메인

최상위 도메인

- `com`, `kr` 등

루트 도메인

- 도메인명이 없음
- 명시적으로 써야 한다면 맨 뒤에 점(`.`)을 찍음
- 루트 도메인의 DNS 서버를 인터넷에 존재하는 모든 DNS 서버에 전부 등록
- 루트 도메인의 DNS 주소에 할당된 IP 주소는 전세계 13개 밖에 없음
- 좀처럼 변경되지 않음
- IP 주소는 13개이나 실제로는 다수의 서버 기계 존재

```
www.lab.glasscom.com
```

1. 클라이언트
2. 가장 가까운 DNS 서버
3. 루트 도메인
4. com 도메인
5. glasscom 도메인
6. lab 도메인

순서

1. 클라이언트 PC -> 가장 가까운 DNS 서버
2. 가장 가까운 DNS 서버 -> 루트 도메인
3. 가장 가까운 DNS 서버 <- 루트 도메인
4. 가장 가까운 DNS 서버 -> com 도메인
5. 가장 가까운 DNS 서버 <- com 도메인
6. 가장 가까운 DNS 서버 -> glasscom 도메인
7. 가장 가까운 DNS 서버 <- glasscom 도메인
8. 가장 가까운 DNS 서버 -> lab 도메인
9. 가장 가까운 DNS 서버 <- lab 도메인
10. 클라이언트 PC <- 가장 가까운 DNS 서버
11. 클라이언트 PC -> www 도메인
12. 클라이언트 PC <- www 도메인

### 4 DNS 서버는 캐시 기능으로 빠르게 회답 가능

현실의 인터넷에서는 한 대의 DNS 서버의 복수의 도메인 정보 등록 가능

DNS 서버는 한번 검사한 이름을 캐시에 등록 가능

## 04 프로토콜 스택에 메시지 송신을 의뢰

### 1 데이터 송·수신 동작 개요

소켓

- 파이프 양 끝에 있는 데이터의 출입구
- 서버측에서 소켓 생성
- 소켓에 클라이언트가 파이프를 연결하기를 기다림
- 데이터를 전부 보내고나면 연결했던 파이프 분리
- 분리 순서는 규칙으로 결정됨

애플리케이션 -> Socket 라이브러리 -> 프로토콜 스택

1. 소켓 작성
2. 서버측 소켓에 파이프 접속
3. 데이터 송·수신
4. 파이프 분리, 소켓 말소

### 2 소켓의 작성 단계

`socket()`

```
<메모리 영역> = gethostbyname(도메인명); // DNS
<디스크립터> = socket(...); // 준비
connect(...); // 접속
write(...); // 송신
<수신 데이터 길이> = read(...); // 수신
close(...); // 연결 끊기
```

디스크립터

- 소켓 식별 역할
- 하나하나의 소켓에 할당한 번호같은 것
- 한 대의 컴퓨터에 브라우저의 2개 창을 열어 2개의 웹 서버에 동시에 액세스 등

### 3 파이프를 연결하는 접속 단계

`connect()`

IP 주소

- 네트워크에 존재하는 각 컴퓨터를 식별하기 위해 각각에 서로 다른 값을 할당한 것
- 각 기기가 아닌 기기에 장착된 각각의 네트워크용 하드웨어에 할당
- 복수의 네트워크 하드웨어를 장착한 기기에는 복수의 주소 할당
- 네트워크의 어느 컴퓨터까지 지정하기 때문에 IP 주소로는 소켓까지는 지정 불가

디스크립터

- 컴퓨터 한 대의 내부에서 소켓을 식별하기 위해 사용
- 소켓을 만들도록 의뢰한 애플리케이션측에 건넴
- 접속 상대에게 건네지 않음

포트 번호

- 접속 상대측에서 소켓을 식별하기 위해 사용
- 서버측의 포트 번호는 애플리케이션의 종류에 따라 미리 결정된 값을 사용한다는 규칙 존재
- 클라이언트측의 소켓의 포트 번호는 소켓을 만들 때 프로토콜 스택이 적당한 값을 골라 할당
- 이 값을 프로토콜 스택이 접속 동작을 실행할 때 서버측에 통지

### 4 메시지를 주고 받는 송·수신 단계

`write()`, `read()`

1. 애플리케이션
   - 메모리
   - 송신 데이터(HTTP 리퀘스트 메시지)
   - `write()`로 디스크립터, 송신 데이터 지정
2. 프로토콜 스택
3. 서버
4. 프로토콜 스택
   - 수신 버퍼
   - 수신 데이터(응답 메시지)
   - `read()`
5. 애플리케이션

### 5 연결 끊기 단계에서 송·수신 단계 종료

`close()`

브라우저가 데이터 수신을 완료하면 송·수신 동작 끝

웹 서버측에서 `close()` 호출해 연결 끊음

- 클라이언트측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 진입
- 브라우저가 `read()`로 수신 동작 의뢰
- `read()`는 수신 데이터 전달 대신 송·수신 동작 완료로 연결이 끊겼다는 사실을 통지
- 브라우저에서도 `close()` 호출해 연결 끊기 단계로 진입

메시지를 실제로 송·수신하는 것

- 프로토콜 스택
- LAN 드라이버
- LAN 어댑터

## 참고

성공과 실패를 결정하는 1%의 네트워크 원리
