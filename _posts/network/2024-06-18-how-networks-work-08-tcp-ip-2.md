---
title: 1%의 네트워크 원리 (08) - TCP/IP의 데이터를 전기 신호로 만들어 보냄 2
date: 2024-06-18 15:14:36 +0900
last_modified_at: 2024-06-21 12:08:51 +0900
categories: [Network]
tags: [network]
---

서버에 접속

# 1%의 네트워크 원리 (08) - TCP/IP의 데이터를 전기 신호로 만들어 보냄 2

## 02 서버에 접속

### 1 접속의 의미

이더넷, 통신 회선

- 항상 케이블이 연결되어 신호를 언제나 보낼 수 있음
- 데이터를 신호로 변환해서 송신하기만 하면 언제든 통신 가능

소켓 생성 직후

- 아직 아무것도 기록되지 않음. 통신 상대 모름
- `socket()`으로 소켓 생성해도 프로토콜 스택에는 아무것도 전달되지 않음

접속 동작의 역할

1. 서버의 IP 주소, 포트 번호를 프로토콜 스택에 알림
   - 클라이언트측, 서버측 동일
2. 클라이언트측에서 서버측에 통신 동작의 개시 전달

접속 동작

1. 통신 상대와의 사이에 제어 정보 주고 받아 소켓에 필요한 정보 기록. 데이터 송·수신이 가능한 상태로 만듦
   - 클라이언트측의 IP 주소, 포트 번호를 서버측에 알리기 등
   - 제어 정보: 데이터 송·수신 동작을 제어하기 위한 정보 (IP 주소, 포트 번호 등)
2. 버퍼 메모리 확보
   - 버퍼 메모리: 송·수신 데이터를 일시적으로 저장하는 메모리 영역

### 2 맨 앞부분에 제어 정보를 기록한 헤더 배치

통신 동작에 이용하는 제어 정보 크게 2종류

1. 헤더에 기입되는 정보
2. 소켓에 기록되는 정보
   - 프로토콜 스택의 메모리 영역
   - 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등 기록

패킷

1. 데이터를 저장한 패킷
   - 애플리케이션 데이터 송·수신 시 패킷
2. 제어 정보만 있는 패킷
   - 제어 동작, 연결 끊기 동작 등 애플리케이션 데이터 없음

```
애플리케이션의 데이터
[ 데이터 조각 ] [ 데이터 조각 ] [ 데이터 조각 ] [ 데이터 조각 ] ...

패킷 (1)
[ 이더넷이나 IP의 제어 정보 ] [ TCP 제어 정보 ] [ 데이터 조각 ]

패킷 (2)
[ 이더넷이나 IP의 제어 정보 ] [ TCP 제어 정보 ]
```

헤더

- TCP 헤더
- IP 헤더
- 이더넷 헤더(MAC 헤더)

### 3 접속 동작의 실제

```
connect(<디스크립터>, <서버 측의 IP 주소, 포트 번호>, ...);
```

- Socket 라이브러리 `connect()` 호출
- 프로토콜 스택의 TCP 담당 부분으로 이동
- 이후 서버의 TCP 담당 부분과 제어 정보 교환

접속 동작 대화

1. 데이터 송·수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더 생성
   - 송신처·수신처의 포트 번호(헤더에서 중요)
   - 컨트롤 비트 SYN 비트를 1로 설정
2. TCP 헤더를 IP 담당 부분에 전달
3. IP 담당 부분이 패킷 송신 동작 실행
4. 네트워크를 통해 패킷이 서버에 도착
5. 서버 측의 IP 담당 부분이 TCP 담당 부분에 전달
6. TCP 헤더를 조사해 수신처 포트 번호에 해당하는 소켓 탐색
   - 해당 소켓에 필요 정보 기록
   - 접속 동작 진행중 상태로 변화
7. 응답을 클라이언트로 반송
   - 송신처·수신처의 포트 번호 기록
   - SYN 비트 1, ACK 비트 1 설정(패킷을 받았음을 알림)
8. 클라이언트가 TCP 헤더를 조사해 접속 동작이 성공했는지 확인
   - SYN이 1이면 접속 동작 성공
   - 소켓에 서버의 IP 주소, 포트 번호 등과 함께 소켓에 접속 완료를 나타내는 제어 정보 기록
9. ACK 비트 1이 설정된 TCP 헤더를 서버로 반송
   - 패킷이 도착한 것을 서버에 알리기 위함
10. 이것이 서버에 도착하면 접속 동작의 대화 종료
    - 이로써 소켓은 데이터를 송·수신할 수 있는 상태

파이프와 커넥션

- 접속은 파이프와 같은 것으로 소켓이 연결되었다 생각할 수 있음
- 파이프를 커넥션(세션)이라고 할 수 있음
- 데이터 송·수신 동작을 계속 하고 있는 동안
- 즉 `close()`를 호출해 연결을 끊을 때까지 계속 존재
- 이렇게 커넥션이 이루어지면 프로토콜 스택의 접속 동작이 끝나므로 `connect()`의 실행이 끝나면서 앱 제어 가능

## 참고

성공과 실패를 결정하는 1%의 네트워크 원리
